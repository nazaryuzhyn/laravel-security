# Laravel Security

- ### [Laravel Security Features](#laravel-security-features-)
    - #### [Laravel Authentication System](#laravel-authentication-system-)
    - #### [Password hashing](#password-hashing-)
    - #### [Encryption](#encryption-)
    - #### [Cookie and Session management](#cookie-and-session-management-)

- ### [Improve Laravel Application Security](#improve-laravel-application-security-)
    - #### [Prevent CSRF Attack](#prevent-csrf-attack-)
    - #### [Prevent DOS Attack](#prevent-dos-attack-)
    - #### [Prevent SQL injection](#prevent-sql-injection-)
    - #### [Prevent XSS Attack](#prevent-xss-attack-)
    - #### [Force HTTPS](#force-https-)

- ### [Additional Security Tips](#additional-security-tips-)

- ### [Laravel Security Packages](#laravel-security-packages-)

<br>
<br>
<br>

# Laravel Security Features <a name="laravel-security-features"></a>

Існують різні типи атак, які можуть бути спрямовані на Laravel додатки, такі як SQL-ін'єкції,
XSS атаки, CSRF атаки, атаки на сесії та багато інших.
Оскільки Laravel має вбудовані механізми безпеки, які допомагають запобігти більшості цих атак,
розробникам важливо знати, як правильно використовувати ці механізми та дотримуватися кращих практик безпеки.

У цій темі ми розглянемо деякі з основних проблем безпеки, які можуть мати загрозу для Laravel додатків,
а також кращі способи безпеки, які розробники можуть використовувати для захисту своїх додатків.

### Laravel Authentication System <a name="laravel-authentication-system"></a>

Laravel має доступний та надійний процес автентифікації користувачів. 
Для полегшення процесу Laravel використовує "Providers" і "Guards". 
Guards перевіряють автентичність користувачів для кожного запиту, 
тоді як Providers допомагають знайти користувачів у базі даних.
Наприклад, Laravel поставляється зі `session` guard, який підтримує state за допомогою session storage та файлів cookie.

Як розробник, все, що вам потрібно зробити, це налаштувати базу даних, контролери та моделі. 
Файл конфігурації автентифікації вашої програми знаходиться за адресою `config/auth.php`. 
Цей файл містить кілька задокументованих параметрів для налаштування поведінки.

### Password hashing <a name="password-hashing"></a>

Для хешування паролів Laravel використовує хеш-функцію Bcrypt, 
яка є однією з найбільш безпечних хеш-функцій на сьогоднішній день.

Драйвер хешування для вашої програми налаштовано у файлі конфігурації `config/hashing.php` вашої програми.
Якщо ви використовуєте [Laravel Starter Kits](https://laravel.com/docs/10.x/starter-kits),
Bcrypt буде використовуватися для реєстрації та автентифікації за замовчуванням.

Bcrypt генерує випадкову послідовність символів, яка додається до пароля перед хешуванням. 
Це забезпечує додатковий рівень безпеки, оскільки дозволяє уникнути зламу паролів 
з використанням таблиць ранжування (rainbow tables).

### Encryption <a name="encryption"></a>

Laravel має вбудовану підтримку шифрування, щоб зберігати конфіденційні дані, 
такі як паролі користувачів, в базі даних в зашифрованому вигляді.

Щоб увімкнути цю функцію безпеки, ви повинні використати `php artisan key:generate` команду у терміналі. 
Команда використовуватиме безпечний генератор випадкових байтів PHP для створення криптографічно безпечного ключа.
У файлі `config/app.php` переконайтеся, що значення для `cipher` налаштовано на один з доступних шифрів, таких як `AES-256-CBC`.
Якщо ви хочете використовувати інший алгоритм шифрування, переконайтеся, що він підтримується вашим сервером. 
Інакше ви можете отримати помилку під час шифрування.
Якщо ви хочете змінити ключ шифрування, відкрийте файл `.env` і встановіть значення для параметра `APP_KEY` на новий ключ.
Ці налаштування дозволять вам захистити дані в вашому проєкті за допомогою шифрування. 
Використовуйте його у поєднанні з іншими методами безпеки, щоб забезпечити максимальний захист вашого вебдодатку та його користувачів.

### Cookie and Session management <a name="cookie-and-session-management"></a>

Захист сеансів користувачів і файлів cookie — чудовий спосіб гарантувати,
що дані кінцевих користувачів зберігаються якомога безпечніше.
Є кілька речей, про які слід пам'ятати, маючи справу з цим у Laravel.

Увімкніть `http_only` як частину сеансу Laravel вашої програми – це можна зробити у `config/session.php` файлі.
Це встановить додатковий рівень безпеки та припинить доступність сеансових файлів cookie в JavaScript.
Установіть низьке значення тайм-ауту простою сеансу, щоб бездіяльність призводила до автоматичного виходу користувача.

Конфігурація домену cookie також міститься у `config.session.php` файлі.
Його слід встановити на, `null` якщо не використовуються субдомени.
Налаштування атрибута домену cookie примусово встановлюватиме cookie `same origin`,
тому лише базовий домен зможе встановити файл cookie.
Також доцільно встановити `same_site` атрибут cookie на `lax` або `strict`
обмежити файли cookie основними або тим самим сайтом.

Найважливішим параметром конфігурації у `config/session.php` файлі є `HTTPS only`.
Увімкнення захищає від атак MITM (man in the middle) і дозволяє лише захищені URL-адреси HTTPS.

## Improve Laravel Application Security <a name="improve-laravel-application-security"></a>

### Prevent CSRF Attack <a name="prevent-csrf-attack"></a>

**CSRF (Cross-Site Request Forgery)** — це тип вебатаки, коли запит з іншого вебсайту намагається надіслати шкідливі запити
до вашої програми від імені користувача без його згоди. Laravel забезпечує вбудований захист від цих атак.
Кожен запит генерує токен, який змінюється при кожному запиті.
Цей токен буде відомий лише програмі, і кожен запит повинен мати цей токен, щоб підтвердити, що запит надходить з того
самого сервера.

Простіше кажучи, захист CSRF гарантує, що кожен запит справді надходить для вашої програми, а не для потенційної
XSS-атаки третьої сторони.
Якщо фільтр CSRF виявляє потенційно небезпечний запит, він повертає помилку HTTP 500 і забороняє доступ.

Якщо ви вручну створюєте форми за допомогою шаблонів Blade (не рекомендується), ви повинні передати туди токен CSRF, як
показано нижче:

```html
<form name="test">

    @csrf

    <!-- Сюди можна вводити інші дані -->

</form>
```

Щоб виключити деякі запити, які надходять із вебхука, створеного за межами нашої програми,
існує захищена властивість `$except` у проміжному програмному забезпеченні `VerifyCsrfToken`:

```php
protected $except = [
    'stripe/*',
    'https://example.com/foo/*',
    'https://example.com/foo/bar',
];
```

### Prevent DOS Attack <a name="prevent-dos-attack"></a>

Атаки DOS (Denial of Service) є одним з найбільш поширених видів кібератак, 
які можуть спричинити перебої в роботі вебдодатків, включаючи додатки на базі Laravel. 
Laravel надає кілька вбудованих механізмів, які можуть допомогти у запобіганні атакам DOS.

Ці типи атак можна розділити на дві популярні категорії:

#### DOS-атаки, які надсилають багато запитів

1. Встановіть ліміт частоти запитів: Ці атаки надсилали б багато запитів PHP, які не були закриті.
   Сервер відповідає на кілька запитів, доки він не зможе підтримувати більше запитів, а пам’ять вийде з ладу, що призведе
   до виходу з ладу нашого сервера. Проміжне програмне забезпечення Laravel RateLimiter допомагають нам справлятися з цими атаками через IP.
   Важливо пам'ятати, що в контексті програми ви можете обробляти, але не зупиняти запити із зовнішнього світу.
   Щоб пом'якшити ці атаки, вам знадобляться інші інструменти розробки та налаштування серверної платформи.
2. Використовуйте кешування: Кешування допомагає зменшити навантаження на сервер і збільшує швидкість відповіді сервера.
   Laravel має вбудовану підтримку для кешування. Використовуйте cache фасад для зберігання даних у кеші.
    ```php
    use Illuminate\Support\Facades\Cache;
    
    Cache::remember('example_data', $ttl, function () {
        // Ваш код для створення даних
    });
    ```
3. Встановіть мінімальний час очікування запитів:
   Встановіть мінімальний час очікування для запитів на сервер, щоб запобігти надмірному навантаженню на сервер.
   Використовуйте опцію `sleep` у своєму коді, щоб встановити мінімальний час очікування.
    ```php
    sleep(1); // Зачекайте 1 секунду, перш ніж генерувати відповідь
    
    return view('example.index');
    ```

#### DOS-атаки, які надсилають великі файли для використання пам’яті сервера

Іншим різновидом цього нападу може бути публічна форма. 
Можливо, у вашій заявці є публічна форма для завантаження файлу.
У цьому випадку великі файли можуть спричинити вичерпання пам'яті сервера.
Потрібно мати на увазі, що сервер повинен обслуговувати дані/ресурси іншим користувачам і обробляти цей тип повідомлень
одночасно.

Щоб впоратися з цією атакою, ви можете використовувати валідатор безпеки Laravel API для перевірки файлу із
запиту.
Ось приклад:

```php
// файл розмір якого має мати рівно 512 кілобайтів
'photo' => ['mimes:jpg,png,webp,bmp', 'file', 'size:512'] 

// максимальний розмір файлу 512 кілобайтів
'photo' => ['mimes:jpg,png,webp,bmp', 'file', 'max:512']
```

### Prevent SQL injection <a name="prevent-sql-injection"></a>

SQL ін'єкція є однією з найбільш поширених атак на вебдодатки, які можуть використовувати хакери, 
щоб викрасти дані або змінити дані в базі даних. 

Спочатку розглянемо впровадження SQL на практичному прикладі. 
Скажімо, у вас є вебдодаток, який відображає профіль користувача за такою URL-адресою:

```
https://example.com/profile.php/?user=john.doe
```

Щоб отримати дані для поточного користувача `john.doe`, буде виконано такий запит:

```sql
SELECT * FROM users WHERE username = 'john.doe'
```

У спробі виконати SQL-ін'єкцію хакер може встановити значення для параметра користувача приблизно так:

```
https://example.com/profile.php/?user=john.doe’ OR 1=1;--
```

Для наведеного вище HTTP-запиту буде виконано такий SQL-запит:

```sql
SELECT * FROM users WHERE username = 'john.doe' OR 1=1;--'
```

Наведений вище SQL-запит завжди повертатиме істину, оскільки `1=1` завжди істина, а з ключовим словом `OR`,
якщо одна сторона істина, весь вираз поверне істину. 
Таким чином, наведений вище запит поверне всі рядки в таблиці `users`. Це типовий приклад SQL-ін'єкції.

Завдяки вразливості, подібній до описаної вище, хакер може впровадити шкідливий код і виконати ще серйозніші операції з вашою базою даних.

Однією з найбільших переваг Laravel є використання Eloquent ORM у його основній структурі. Це використовує прив'язку PDO
для захисту від впровадження SQL під час взаємодії з підключеною базою даних.

Тепер давайте розглянемо кілька прикладів для запобігання SQL-ін'єкцій:

1. Використовуйте параметризовані запити:
   Використання параметризованих запитів в Laravel дозволяє передавати параметри окремо від запиту SQL. 
   Це допомагає уникнути SQL ін'єкцій, оскільки параметри не обробляються як частини запиту SQL.
    ```php
    DB::select('SELECT * FROM users WHERE id = ?', [$id]);
    ```
   У цьому прикладі ми використовуємо параметризований запит до бази даних.
   Ми передаємо змінну `$id` як параметр запиту, і вона не обробляється як частина SQL запиту.
2. Використовуйте ORM: Використання ORM допомагає уникнути SQL ін'єкцій, 
   оскільки всі запити до бази даних генеруються з використанням об'єктів PHP, а не прямо з SQL запитів.
    ```php
    User::where('id', $id)->first();
    ```
   У цьому прикладі ми використовуємо ORM, щоб знайти користувача за його ідентифікатором. 
   ORM дозволяє нам уникнути написання SQL запитів вручну.
3. Використовуйте фасад Query Builder: Laravel надає фасад Query Builder, 
   який дозволяє будувати SQL запити з використанням об'єктів PHP. 
   Використання Query Builder допомагає уникнути SQL ін'єкцій, оскільки всі запити генеруються з використанням об'єктів PHP.
    ```php
    DB::table('users')->where('name', '=', $name)->get();
    ```
   У цьому прикладі ми використовуємо фасад Query Builder, щоб знайти користувачів за їх іменем. 
   Query Builder дозволяє нам будувати SQL запити з використанням об'єктів PHP.
4. Використовуйте вбудовані методи перевірки вхідних даних: Laravel має вбудовані методи перевірки вхідних даних, 
   такі як `validate()` і `Rule()`. Використовуючи ці методи, ви можете перевіряти вхідні дані на наявність SQL ін'єкцій.
    ```php
    $request->validate([
        'name' => 'required|string',
    ]);
    ```

### Prevent XSS Attack <a name="prevent-xss-attack"></a>

XSS (Cross-Site Scripting) - це вразливість безпеки, яка дозволяє зловмиснику розміщувати клієнтські скрипти
(зазвичай JavaScript) на вебсторінках.
XSS-атаки відбуваються, коли зловмисник використовує вебпрограму для надсилання шкідливого коду, як правило,
у формі сценарію сторони браузера, іншому кінцевому користувачеві.

Хрестоматійний метод запобігання XSS атак у Laravel - це використання Blade шаблонів для відображення даних.
Blade шаблони автоматично екранують будь-який ввід, перед тим як він буде відображений на сторінці.

Тепер, коли ми знаємо, що таке XSS, давайте подивимося на XSS у Laravel і як можна уникнути цього.

**Очищення вхідних даних:**

Очищення вхідних даних включає методи визначення та видалення можливих вхідних елементів рядків,
які можуть бути шкідливими для вашої програми.
Ось як ми можемо очистити введення, видаливши теги за допомогою функції PHP `strip_tags`.

```php
$cleanedName = strip_tags($request->input('name'));

$task = new Task;
$task->name = $cleanedName;
$task->save();
```

**Middleware для перевірки вхідних даних:**

Розглянемо додавання авторизації та перевірки одночасно у вебформах. Laravel для цього пропонує клас `Request`.
Ви можете створити middleware, за допомогою такої команди: `php artisan make:middleware XssSanitization`
Ця команда згенерує файл, як показано нижче або просто скопіюйте та вставте цей код у свій middleware файл.

```php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Support\Facades\App;

class HttpsMiddleware {

    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        $input = $request->all();
        
        array_walk_recursive($input, function (&$input) {
            $input = strip_tags($input);
        });
        
        $request->merge($input);
        
        return $next($request);
    }
}
```

Далі зареєструйте цей middleware у нашому файлі який знаходиться на `app/Http/Kernel.php`.

```php
protected $routeMiddleware = [
    // ...

    'XssSanitizer' => \App\Http\Middleware\XssSanitizer::class,
];
```

Тепер ви можете використовувати middleware `XssSanitization` у маршрутах.

```php
Route::middleware(['XssSanitization'])->group(function () {
    // ...
});
```

### Force HTTPS <a name="force-https"></a>

Коли ви розгортаєте свій вебсайт на HTTP, усі обмінювані дані, включаючи паролі та інші дані,
надсилаються у вигляді простого вмісту.
Таким чином будь-хто може легко вкрасти будь-кого або будь-що між передачею.
Тому, щоб зберегти цю інформацію в безпеці, завжди розгортайте свої вебпрограми на HTTPS,
щоб захистити конфіденційну інформацію.

Ви можете створити middleware, виконавши команду: `php artisan make:middleware HttpsMiddleware`
Ця команда згенерує файл, як показано нижче або просто скопіюйте та вставте цей код у свій middleware файл.
Це перевірить, чи запит безпечний, якщо він не безпечний, він переспрямує користувача на безпечну URL-адресу https.

```php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Support\Facades\App;

class HttpsMiddleware {

    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if (!$request->secure() && app()->environment('production')) {
            return redirect()->secure($request->getRequestUri());
        }
    }
}
```

Потім у своєму `Kernel` файлі, який знаходиться на `app/Http/Kernel.php`,
ви можете розмістити створений middleware у вебгрупі,
яка застосовується до кожного запиту у вашій програмі Laravel.

```php
protected $middlewareGroups = [
    'web' => [
        // ...
        
        \App\Http\Middleware\HttpsMiddleware::class
    ],
    
    'api' => [
        'throttle:60,1',
    ],
];
```

## Additional Security Tips <a name="additional-security-tips"></a>

Ось список порад, які можуть підвищити безпеку вашої програми:

#### Використовуйте Honeypot у будь-якій публічній формі

Будь-яку публічну форму може подати кожен.
Щоб уникнути зловмисних запитів від ботів, ви можете встановити прихований ввід.
Боти заповнять вхідні дані (звичайний користувач не повинен заповнювати приховані введення),
а потім ви можете використовувати заборонене правило перевірки з валідатора Laravel:

```php
// Поле має бути відсутнім або порожнім.

'honey_pot_field' => ['prohibited'],
```

#### Постійно змінюйте значення APP_KEY

Це може бути складно, якщо у вас є моделі сховищ із шифруванням даних.
У цьому випадку я пропоную використовувати пакет, який обробляє це за вас:
[rawilk/laravel-app-key-rotator](https://github.com/rawilk/laravel-app-key-rotator)
Пакет обертає `APP_KEY`, розшифровуючи та знову шифруючи всі моделі, які були зашифровані.

#### Надсилати електронний лист, коли користувач оновлює E-mail

Laravel надає функцію надсилання електронного листа для підтвердження нового
облікового запису з новою реєстрацією користувача.
Однак, коли той самий користувач змінює обліковий запис електронної пошти,
він не підтверджує нову адресу електронної пошти.
Цей процес можна автоматизувати за допомогою пакета:
[protonemedia/laravel-verify-new-email](https://github.com/protonemedia/laravel-verify-new-email)
Те саме стосується зміни пароля.

#### Обережно реєструйте облікові дані SSH на своєму сервері

Намагайтеся підключатися за допомогою SSH лише з місць, де ваше з’єднання є «безпечним».
Уникайте публічних підключень Wi-Fi.

#### Встановити термін служби токенів

Laravel Passport:

У вашому `app/providers/AuthServiceProvider.php` ви можете встановити певний час життя для кожного маркера:

```php
/** 
 * Register any authentication / authorization services. 
 * 
 * @return void 
*/ 
public function boot() 
{    
    $this->registerPolicies();

    Passport::routes();
    Passport::tokensExpireIn(now()->addDays(15));
    Passport::refreshTokensExpireIn(now()->addDays(30));
    Passport::personalAccessTokensExpireIn(now()->addMonths(6));
}
```

Laravel Sanctum:

Просто опублікуйте файл конфігурації sanctum і змініть значення. Час буде встановлено в хвилинах:

    php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"

```php
'expiration' => null,
```

Якщо ви налаштували час закінчення терміну дії токена для вашої програми, 
ви також можете запланувати завдання для видалення прострочених токенів вашої програми. 
Sanctum містить `sanctum:prune-expired` команду Artisan, яку ви можете використовувати для цього. 
Наприклад, ви можете налаштувати заплановані завдання для видалення всіх прострочених записів з бази даних, 
термін дії яких минув принаймні 24 години:

```php
$schedule->command('sanctum:prune-expired --hours=24')->daily();
```

## Laravel Security Packages <a name="laravel-security-packages"></a>

### [Laravel Security Checker](https://github.com/enlightn/laravel-security-checker)

Пакет який сканує ваш проєкт Laravel на наявність відомих уразливостей у безпеці та надає рекомендації щодо їх усунення.

### [Laravel Honeypot](https://github.com/spatie/laravel-honeypot)

Laravel Honeypot надає спосіб виявлення та блокування спаму у формах і коментарях вашої програми Laravel.

### [Laravel Firewall](https://github.com/akaunting/laravel-firewall)

Laravel Firewall забезпечує брандмауер, який може блокувати запити на основі IP-адреси, агента користувача або країни.
Він також включає захист від грубої сили та функцію чорного/білого списку.

### [Laravel Security Headers](https://github.com/bepsvpt/secure-headers)

Цей пакет надає middleware, який додає заголовки безпеки до HTTP-відповідей програми Laravel.
Це може допомогти захистити вашу програму від різних типів атак, у тому числі XSS, CSRF і clickjacking.
